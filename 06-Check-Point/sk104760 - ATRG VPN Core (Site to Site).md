**This article is dedicated to VPN Core (Site-to-Site) only.**Â 

Check Point Security Gateway performs IPSec encryption using the following two components:

-   VPN is supported by all modes of Check Point cluster.
    
-   In addition to synchronizing the connections and various inspection tables, cluster members also synchronize the SA kernel tables, which contain information about both the IKE SAs and IPSec SAs.
    
-   All IKE SAs and IPSec SAs will always be assigned to the Cluster VIP address.
    
-   If a cluster member gets an encrypted packet with an SPI it does not know (even if the other cluster member does), the packet would be dropped on "unknown SPI".
    
-   If the IKE negotiation is initiated from VPN peer to the cluster, the stickiness of the internal cluster decision function ensures that the entire negotiation is performed against the same cluster member.
    
    If the IKE negotiation is initiated by the cluster in Load Sharing mode, then IKE packets from VPN peer might be assigned by internal cluster decision function to another cluster member that is not yet aware of this IKE negotiation. For this reason, IKE forwarding mechanism is used to ensure that the entire IKE negotiation is performed against one cluster member (and if IKE packets get to the "wrong" cluster member, they will be forwarded to the "right" cluster member).
    
-   The IKE Forwarding mechanism uses the kernel table _SEP\_my\_IKE\_packet_ that records each unknown first IKE packet.
    
-   In IKE negotiation between Check Point gateways, each side has a unique cookie that is valid and used during the entire IKE Phase 1 validation time. Each IKE packet contains that cookie and also a Message ID (in Phase 1 packets, this ID equals zero; in Phase 2 packets, this ID is unique for each Phase 2 negotiation).
    
-   Inbound IKE flow:
    
    1.  Cluster member gets IKE packet.
        
    2.  If this High Availability cluster mode, then the Active cluster member takes ownership on that IKE negotiation by writing in the _SEP\_my\_IKE\_packet_ table the "cookie + msg\_id" of the IKE packet, with its own IP address as the cluster peer.
        
    3.  If this Load Sharing cluster mode, then the member resolves the cookie and the Message ID from the IKE packet (in Phase 1 the Message ID is simply zero).
        
    4.  Cluster member searches in the _SEP\_my\_IKE\_packet_ table for entry that matches to that key ("cookie + msg\_id").
        
    5.  If such entry already exists, it means that this is not the first IKE packet in that IKE negotiation. Therefore, cluster member checks in the _SEP\_my\_IKE\_packet_ table what is the cluster peer - the member that manages the IKE negotiation.
        
    6.  If cluster member that manages the IKE negotiation is the local machine, then cluster member just keeps handling the IKE packet as usual. Otherwise, cluster member changes the destination on the IKE packet according the cluster peer that is written in the _SEP\_my\_IKE\_packet_ table and forwards the IKE packet to that peer member at the end of the chain's treatment (this forwarded IKE packet does not need to pass the chains again on the peer member).
        
    7.  If such entry does not exist in the _SEP\_my\_IKE\_packet_ table yet, it means that this is the first IKE packet of the IKE negotiation. Therefore, this cluster member takes ownership on that IKE negotiation by writing in the _SEP\_my\_IKE\_packet_ table the "cookie + msg\_id" of the IKE packet, with its own IP address as the cluster peer.
        
-   Outbound IKE flow:
    
    1.  When cluster member needs to initiate IKE negotiation, it checks that there is no entry in the _SEP\_my\_IKE\_packet_ table with that key "cookie + msg\_id", and sets new entry in the table with its own IP address as the cluster peer.
        
-   When IKE negotiation is performed with a 3rd party cluster, the unique IP address that written in the _SEP\_my\_IKE\_packet_ table is the IP address of the Sync interface of the 3rd party cluster member (because in 3rd party cluster, the cluster VIP could be identical the physical member IP address).
    
-   In Load Sharing cluster, it could be case that IKE Phase 2 packets get to a member that does not have the IKE Phase 1 keys yet, because the SAs from IKE Phase 1 were not synchronized yet. Therefore, IKE Phase 2 packets are forwarded to the member that performed the IKE Phase 1 negotiation. When IKE Phase 2 packet is received, cluster member gets its cookie and checks if IKE SA exists in the table _IKE\_SA\_table_. If this key is found, then cluster member handles that IKE negotiation. If such key does not exist yet, then cluster member checks which cluster peer member performed the IKE Phase 1 negotiation checking the _SEP\_my\_IKE\_packet_ table and forwards the IKE packet to that cluster peer member. If the relevant entry does not exist in the _SEP\_my\_IKE\_packet_ table for this cookie or the cluster member that performed IKE Phase 1 negotiation is the current cluster member, then something is not working correctly.
    
-   In Load Sharing cluster mode, only the _inbound SAs_ are synchronized. The _outbound SAs_ are not synchronized (created separately on each cluster member) to prevent IKE replay attack. However, cluster members still store an entry in the _outbound\_SPI_ table (with "0" value), for a case that SA deletion request is received on the cluster member that does not own this outbound SA.
    
    If this entry is not stored on all cluster members, and a cluster member is not able to find the entry in his _outbound\_SPI_ table, then it will do nothing and this outbound SA will continue to exist on the cluster member that does own this outbound SA. Therefore, all the SAs are stored on all cluster members, and if the deletion request gets to one of the cluster members, it deletes the entry of this SA and synchronizes the table to all cluster peer members. Each cluster member uses only in his own outbound SA.
    

Kernel tables (also known as State tables) are used to keep state information, which the FireWall Virtual Machine, and other components of the Security Gateway need to correctly inspect the packet.

The tables are actually the 'memory' of the Virtual Machine in the kernel, and are the key component of Check Point Stateful Inspection technology.

State tables are implemented as dynamic hash tables in kernel memory.

All field values are in hexadecimal (for some tables can be converted to decimal), apart from the time-out value at the end of the entry, when present.

<table><tbody><tr><td>Parameter/Flag</td><td>Description</td></tr><tr><td><code>TABLE</code></td><td>Either the name, or ID number of the kernel table</td></tr><tr><td><code>-s</code></td><td>Displays a short summary of the table's information (the current total number and peak number of connections)</td></tr><tr><td><code>-f</code></td><td>Displays a formatted version of the table's contents (every table may have its own specific format style).</td></tr><tr><td><code>-r</code></td><td>Used with "-f" flag. Resolves IP addresses in formatted output.</td></tr><tr><td><code>-u</code></td><td>Displays an unlimited output (entire table's contents).</td></tr><tr><td><code>-m MaxValues</code></td><td>Displays table's contents limited to "MaxValues" entries.</td></tr></tbody></table>

<table id="KernelTablesTable"><tbody><tr><td>Table Name</td><td>Description</td></tr><tr><td><code>connections</code></td><td><p>Main table that holds data on all active connections. For more information, refer to <a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk65133" target="_blank" rel="noopener">sk65133 - Connections Table Format</a>.</p></td></tr><tr><td><code>crypt_resolver_db</code></td><td><ul type="circle"><li><p>Maintains a list of VPN links and their status (alive, dead, or unknown).</p></li><li><p>A probing protocol (RDP packets on UDP port 259) is used to determine the link's status.</p></li><li><p>This table is used in case of multi-homed configuration, dynamic interface resolving and MEP configurations.</p></li><li><p>The table is used in order to find out which link to use (according to the links' status and the configured priority).</p></li><li><p>Default expiration time is 30 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li><li><p>Table entry: &lt;<em>Dest_IP, Source_IF, Next_Hop_IP; Status</em>&gt;, where:</p><ul type="square"><li><p>Dest_IP - The destination IP address of the link we query</p></li><li><p>Source_IF - The source interface index of the link we query ("-1" if multi-homed is not used)</p></li><li><p>Next_Hop_IP - The next hop IP address of the link we query ("0" if multi-homed is not used)</p></li><li><p>Status - Status of a link (0=unknown, 1=alive, or 2=dead)</p></li></ul></li></ul></td></tr><tr><td><code>cluster_connections_nat</code></td><td><ul type="circle"><li><p>On the inbound chain when we are at the decrypt chain handler we check whether the incoming packet is destined to the IKE port. If this is the case, along with the fact that we are in a cluster configuration we do need to NAT the connection (this is required for the IKE negotiation - it must see a specific IP with which it negotiates).</p></li><li><p>On the decrypt chain, a message is written, so when the policy chain sees it it will write to this table. In this manner, DoS attacks with spoofed packets that write to this table are avoided.</p></li><li><p>The policy chain checks if there is a message for us from the decrypt chain, which tells that this packet was NATed in the inbound direction. If so, we set this table to contain the pre-NAT destination IP address, to be used in the outbound direction, in order to return from that IP address.</p></li><li><p>Default expiration time is 600 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li><li><p>Table entry: &lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol; Original_IP_Address</em>&gt;, where:</p><ul type="square"><li><p>Source_IP - The source IP address</p></li><li><p>Dest_IP - The destination IP address</p></li><li><p>Source_Port - The source port</p></li><li><p>Dest_Port - The destination port</p></li><li><p>Protocol - Protocol number</p></li><li><p>Original_IP_Address - The source IP address as seen on outbound packets</p></li></ul></li></ul></td></tr><tr><td><code>cryptlog_table</code></td><td><ul type="circle"><li><p>Used to record kernel events - to indicate that a trap was issued to the vpnd daemon. The vpnd daemon will subsequently handle the request.</p></li><li><p>Default expiration time is 120 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li><li><p>Table entry: &lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol</em>&gt;, where:</p><ul type="square"><li><p>Source_IP - The source IP address</p></li><li><p>Dest_IP - The destination IP address</p></li><li><p>Source_Port - The source port</p></li><li><p>Dest_Port - The destination port</p></li><li><p>Protocol - Protocol number</p></li></ul></li></ul></td></tr><tr><td><code>DAG_ID_to_IP</code></td><td><ul type="circle"><li><p>Used when DAIP gateways have achieved IKE negotiation with the Security Gateway. For each such DAIP gateway, an association is kept between the ID, also called the "bogus IP", of the DAIP gateway as it appears in the database, to the real IP address, from which the negotiation was received. Each time a new negotiation is finalized from a DAIP gateway, the corresponding entry is created, or updated.</p></li><li><p>No expiration time.</p></li><li><p>Synchronized in cluster.</p></li><li><p>Table entry: &lt;<em>DAG_ID; DAG_IP</em>&gt;, where:</p><ul type="square"><li><p>DAG_ID - ID of the DAIP gateway (a bogus IP address in the form 0.0.x.x)</p></li><li><p>DAG_IP - IP address that is currently assigned to the DAIP gateway</p></li></ul></li></ul></td></tr><tr><td><code>DAG_IP_to_ID</code></td><td><ul type="circle"><li><p>Used when DAIP gateways have finalized IKE negotiations with the Security Gateway. This table contains the same information as <em>DAG_ID_to_IP</em>, but with the current IP address of the DAIP gateway as the key.</p></li><li><p>No expiration time.</p></li><li><p>Synchronized in cluster.</p></li><li><p>Table entry: &lt;<em>DAG_IP; DAG_ID</em>&gt;, where:</p><ul type="square"><li><p>DAG_IP - IP address that is currently assigned to the DAIP gateway</p></li><li><p>DAG_ID - ID of the DAIP gateway (a bogus IP in the form 0.0.x.x)</p></li></ul></li></ul></td></tr><tr><td><code>decryption_pending</code></td><td><ul type="circle"><li>Obsolete in R77.10 and higher.</li><li><p>Stores a connection 5-tuple for a connection, whose RDP negotiation has been completed and is ready.</p></li><li><p>Default expiration time is 120 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li><li><p>Table entry: &lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol; Key, Entry</em>&gt;, where:</p><ul type="square"><li><p>Source_IP - The source IP address</p></li><li><p>Dest_IP - The destination IP address</p></li><li><p>Source_Port - The source port</p></li><li><p>Dest_Port - The destination port</p></li><li><p>Protocol - Protocol number</p></li><li><p>Key - Key that was generated from the FWZ key exchange protocol</p></li><li><p>Entry - Flags for logging purpose</p></li></ul></li></ul></td></tr><tr><td><code>encryption_requests</code></td><td><ul type="circle"><li><p>Stores a connection 5-tuple of connections, for which traps are sent to the vpnd daemon to initiate the encryption. This is performed, to avoid sending multiple traps to the vpnd daemon for the same issue.</p></li><li><p>In the initiation phase of the encryption, connections that are to be encrypted are stored in this table, up to the point of actual encryption.</p></li><li><p>Default expiration time is 90 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li><li><p>Table entry: &lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol; Key, VPNConnType, ActionType, LogType, Error</em>&gt;, where:</p><ul type="square"><li><p>Source_IP - The source IP address</p></li><li><p>Dest_IP - The destination IP address</p></li><li><p>Source_Port - The source port</p></li><li><p>Dest_Port - The destination port</p></li><li><p>Protocol - Protocol number</p></li><li><p>Key - Key generated by the FWZ key exchange protocol</p></li><li><p>VPNConnType - VPN Connection Type</p></li><li><p>ActionType - Action Type</p></li><li><p>LogType - VPN log level</p></li><li><p>Error - Error string if any</p></li></ul></li></ul></td></tr><tr><td><code>IKE_SA_table</code></td><td><ul type="circle"><li><p>Contains information about all ISAKMP SAs.</p></li><li><p>Entries from this table are used to conduct IKE Quick Mode negotiation of IPsec SA.</p></li><li><p>Entries are extracted from this table when the vpnd daemon is trapped for IPsec SA renewal.</p></li><li><p>Default expiration time is 3600 seconds.</p></li><li><p>Synchronized in cluster.</p></li><li><p>Table entry is:</p><p>either<br>&lt;<em>Peer_IP ,0 , CookieI, CookieR; IKE_SA, IKE_SA_flag, RenegotiationTime; Timeout</em>&gt;</p><p>or</p><p>&lt;<em>Peer_IP, 0; IKE_SA, CookieI, CookieR, IKE_SA_flag, RenegotiationTime; Timeout</em>&gt;</p><p>where:</p><ul type="square"><li><p>Peer_IP - IP address of IKE peer</p></li><li><p>CookieI - initiator cookie (8 bytes in host byte order)</p></li><li><p>CookieR - responder cookie (8 bytes in host byte order)</p></li><li><p>IKE_SA - ISAKMP SA data in Check Point code</p></li><li><p>IKE_SA_flag - one of these values: 0x01=mobile, 0x02=initiator, 0x03=DAIP</p></li><li><p>RenegotiationTime - The renegotiation time of the SA</p></li><li><p>Timeout - How much time remained to expiration time</p></li></ul></li></ul></td></tr><tr><td><code>ike2esp</code></td><td><ul type="circle"><li><p>Holds IKE-to-ESP mappings for cookies.</p></li><li><p>No expiration time.</p></li><li><p>Not synchronized between cluster members.</p></li></ul></td></tr><tr><td><code>ike2peer</code></td><td><ul type="circle"><li><p>Holds IKE-to-Peer mappings for cookies.</p></li><li><p>No expiration time.</p></li><li><p>Not synchronized between cluster members.</p></li></ul></td></tr><tr><td><code>inbound_SPI</code></td><td><ul type="circle"><li><p>Contains all Inbound IPSec SAs (IKE negotiation results in such a SA).</p></li><li><p>Default expiration time is 3600 seconds.</p></li><li><p>Synchronized in cluster.</p></li><li><p>Table entry: &lt;<em>SPI; SA, Host_IP, UserPeer_Method, Peer_IP; Timeout</em>&gt;, where:</p><ul type="square"><li><p>SPI - The inbound SPI</p></li><li><p>SA - The inbound SA that is pointed by the inbound SPI</p></li><li><p>Host_IP - The host IP address</p></li><li><p>UserPeer_Method - The User Peer method</p></li><li><p>Peer_IP - The peer IP address, with which the SA was established</p></li><li><p>Timeout - How much time remained to expiration time</p></li></ul></li></ul></td></tr><tr><td><code>initial_contact_pending</code></td><td><ul type="circle"><li><p>Holds IKE cookies.</p></li><li><p>If we cannot establish an IKE-to-Peer mapping yet, these IKE cookies are marked for later processing. When an IPSEC SA for these IKE cookies is later written, they will be processed.</p></li><li><p>Default expiration time is 240 seconds.</p></li><li><p>Not synchronized between cluster members.</p></li></ul></td></tr><tr><td><code>ipalloc_tab</code></td><td><ul type="circle"><li><p>This table is used to issue IP address lease extensions requests.</p></li><li><p>This can be done from either DHCP Server, or the IP Pool mechanism.</p></li><li><p>This table is used only by the L2TP modules, for which the Security Gateway is responsible for issuing the lease-extension requests, rather than the client.</p></li><li><p>Each entry in the table has the IP address lease time as the timeout of the entry.</p></li><li><p>When we see that half of the lease time has elapsed, a trap is given to the vpnd daemon to issue new extension request.</p></li><li><p>Default expiration time is 2147483647 seconds (2<sup>31</sup>-1), i.e., never expires.</p></li><li><p>Synchronized in cluster.</p></li><li><p>Table entry: &lt;<em>Client_MAC, IP_Alloc_Method, Last_Trap_Time;</em>&gt;, where:</p><ul type="square"><li><p>Client_MAC - The client MAC address</p></li><li><p>IP_Alloc_Method - IP address allocation method (IP Pool, DHCP, etc.)</p></li><li><p>Last_Trap_Time - Time when the last trap to the vpnd daemon was made (to request IP address lease extension)</p></li></ul></li></ul></td></tr><tr><td><code>IPSEC_mtu_icmp</code></td><td><ul type="circle"><li>Holds the source IP address and the destination IP address as found in packet that we want to encrypt for a predefined time, but the "Don't Fragment" Bit (DF) of the packet is set and the packet's expected size is larger than the host's MTU.</li><li>The above values are entered to this table in order to mark the MTU behavior of this source host.</li><li>The kernel will fragment packets as long as there is no need to send back ICMP Need-To-Fragment and that Src and Dst in the table match the one on the "problematic" packet.</li><li>The above behavior is desired in order to avoid as much as possible packet fragmentation in the kernel since it is a very resource-consuming task.</li><li>This table is tightly coupled with the <em>IPSEC_mtu_icmp_wait</em> table.</li><li>Default expiration time is 600 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Source_IP, Dest_IP</em>&gt;, where:<br><ul type="square"><li>Source_IP - The source IP address</li><li>Dest_IP - The destination IP address</li></ul></li></ul></td></tr><tr><td><code>IPSEC_mtu_icmp_wait</code></td><td><ul type="circle"><li>This table was introduced to solve a behavior where we opened an IPsec connection from the machine itself (be it a FW machine or Remote Access machine), if the packet is too big and has the "Don't Fragment" Bit (DF), the VPN kernel sends an ICMP Need-To-Fragment packet to the machine's TCP/IP stack. This packet might not be processed correctly. The end result is the connection being stuck.</li><li>Holds the source IP address and the destination IP address as found in packet that we want to encrypt for a predefined time, but the "Don't Fragment" Bit (DF) of the packet is set and the packet's expected size is larger than the host's MTU.</li><li>The entries are held for a predefined time where within this time frame, we do generate ICMP Need-To-Fragment packet (for packets that had this DF bit and MTU limitation conflict). Those packets are rejected.</li><li>The above values are entered to this table in order to mark the MTU behavior of this source host.</li><li>This table is tightly coupled with the <em>IPSEC_mtu_icmp</em> table.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Source_IP, Dest_IP</em>&gt;, where:<br><ul type="square"><li>Source_IP - The source IP address</li><li>Dest_IP - The destination IP address</li></ul></li></ul></td></tr><tr><td><code>L2TP_lookup</code></td><td><ul type="circle"><li>Represents an established L2TP session, with the lookup in reverse.</li><li>No expiration time.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Assigned_IP; Peer_Port, Tunnel_ID, Session_ID, Peer_Tunnel_ID, Peer_Session_ID</em>&gt;, where:<br><ul type="square"><li>Assigned_IP - IP address assigned to the peer</li><li>Peer_Port - UDP port of the peer (always 1701)</li><li>Tunnel_ID - Tunnel identifier assigned by us</li><li>Session_ID - Session identifier assigned by us</li><li>Peer_Tunnel_ID - Tunnel identifier assigned by peer</li><li>Peer_Session_ID - Session identifier assigned by peer</li></ul></li></ul></td></tr><tr><td><code>L2TP_MSPI_cluster_update</code></td><td><ul type="circle"><li>Used in cluster to map MSPIs to peer, methods, IDs so that the matching MSPIs can be found.</li><li>Default expiration time is 600 seconds.</li><li>Synchronized in cluster.</li></ul></td></tr><tr><td><code>L2TP_sessions</code></td><td><ul type="circle"><li>Represents an L2TP session.</li><li>No expiration time.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_IP, Peer_Port, Tunnel_ID, Session_ID; Status, Peer_Tunnel_ID, Peer_Session_ID, Timestamp, Assigned_IP, IPsec_MSPI, L2TP_MSPI, My_Object_IP, Cluster_Member_ID</em>&gt;, where:<br><ul type="square"><li>Peer_IP - IP address assigned to the peer</li><li>Peer_Port - UDP port of the peer (always 1701)</li><li>Tunnel_ID - Tunnel identifier assigned by us</li><li>Session_ID - Session identifier assigned by us</li><li>Status - Status of session</li><li>Peer_Tunnel_ID - Tunnel identifier assigned by peer</li><li>Peer_Session_ID - Session identifier assigned by peer</li><li>Timestamp - Approximate time of last packet</li><li>Assigned_IP - Assigned IP address</li><li>IPsec_MSPI - MSPI used for decrypting messages</li><li>L2TP_MSPI - MSPI used for the session</li><li>My_Object_IP - My IP address (used for sync)</li><li>Cluster_Member_ID - Cluster member ID</li></ul></li></ul></td></tr><tr><td><code>L2TP_tunnels</code></td><td><ul type="circle"><li>Represents an L2TP tunnel.</li><li>Default expiration time is 60 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_IP, Peer_Port, Tunnel_ID; Status, Peer_Tunnel_ID, Peer_Session_ID, Timestamp, Next_Outbound, Next_Expected_Outbound, Last_Inbound, Session_ID, IPsec_MSPI, My_Object_IP, Owner_IP, Cluster_Member_ID</em>&gt;, where:<br><ul type="square"><li>Peer_IP - IP address assigned to the peer</li><li>Peer_Port - UDP port of the peer (always 1701)</li><li>Tunnel_ID - Tunnel identifier assigned by us</li><li>Status - Status of session</li><li>Peer_Tunnel_ID - Tunnel identifier assigned by peer</li><li>Peer_Session_ID - Session identifier assigned by peer</li><li>Timestamp - Approximate time of last packet</li><li>Next_Outbound - Message ID of next outbound message</li><li>Next_Expected_Outbound - Message ID of next outbound message expected by peer</li><li>Last_Inbound - Message ID of last received message</li><li>Session_ID - Session identifier assigned by us</li><li>IPsec_MSPI - MSPI used for decrypting messages</li><li>My_Object_IP - My IP address (used for sync)</li><li>Owner_IP - Owner's IP address</li><li>Cluster_Member_ID - Cluster member ID</li></ul></li></ul></td></tr><tr><td><code>MSPI_by_methods</code><p>In R80.10, this table<br>was replaced by the<br>global table called<br><code>meta_sas</code><br>(that also uses a<br>local cache table<br><code>local_meta_sas</code>)</p></td><td><ul type="circle"><li>This table provides a way to access an actual SA, through MSA, which is pointed to by the MSPI.</li><li>Used by the vpnd daemon to decide whether a Meta SA (MSA) exists for a given set of methods, peers, and IDs.</li><li>For cluster synchronization, the Meta SPI (MSPI) is stored and not the MSA.</li><li>For mobile users, the user name on the MSA should also be verified to determine if the MSA is appropriate, and not just the peer, methods, and IDs.</li><li>Default expiration time is 2147483647 seconds (2<sup>31</sup>-1), i.e., never expires.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Peer_IP, Method1, Method2, MyRangeFirstIP, MyRangeLastIP, PeerRangeFirstIP, PeerRangeLastIP; MSPI</em>&gt;, where:<br><ul type="square"><li>Peer_IP - The peer IP address for which we want the MSPI (for SecuRemote - internal IP)</li><li>Method1 - The encryption and authentication methods for this peer gateway</li><li>Method2 - The encryption and authentication methods for this peer G</li><li>MyRangeFirstIP - The subnet's first IP address</li><li>MyRangeLastIP - The subnet's last IP address</li><li>PeerRangeFirstIP - The subnet's first IP address</li><li>PeerRangeLastIP - The subnet's last IP address</li><li>MSPI - The MSPI on this peer</li></ul></li></ul></td></tr><tr><td><code>MSPI_cluster_map</code></td><td><ul type="circle"><li>Maps between MSPI on cluster peer members, to the MSPI on this cluster member.</li><li>This table is important in High Availability Single Entry Point (SEP) configurations.</li><li>Default expiration time is 2147483647 seconds (2<sup>31</sup>-1), i.e., never expires.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Cluster_Peer_IP, My_MSPI; Peer_MSPI</em>&gt;, where:<br><ul type="square"><li>Cluster_Peer_IP - The IP address of the cluster peer member</li><li>My_MSPI - The MSPI on this cluster member</li><li>Peer_MSPI - The MSPI on the cluster peer member</li></ul></li></ul></td></tr><tr><td><code>MSPI_cluster_update</code></td><td><ul type="circle"><li>Used for synchronization of the MSPI numbers between the cluster members.</li><li>Each member has internal MSPI number that does not necessarily correspond to the MSPI number of the cluster peer members.<br>Therefore, MSPI needs to be translated from the MSPI of cluster peer member to the local MSPI.</li><li>When one of the cluster members creates a new MSPI, it writes it to this table.</li><li>Default expiration time is 600 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_Member_IP, Peer_Member_ID, Peer_MSPI; Methods</em>&gt;, where:<br><ul type="square"><li>Peer_Member_IP - The IP address of cluster peer member</li><li>Peer_Member_ID - The ID cluster peer member</li><li>Peer_MSPI - MSPI of cluster peer member</li><li>Methods - Attribute of the methods that was used to create that MSPI on that cluster member</li></ul></li></ul></td></tr><tr><td><code>MSPI_cluster_reverse_map</code></td><td><ul type="circle"><li>Used to map between MSPI on this cluster member to MSPI on cluster peer member.</li><li>This table is important in High Availability Single Entry Point (SEP) configurations.</li><li>Default expiration time is 2147483647 seconds (2<sup>31</sup>-1), i.e., never expires.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_Member_IP, My_MSPI; Peer_MSPI</em>&gt;, where:<br><ul type="square"><li>Peer_Member_IP - The IP address of cluster peer member</li><li>My_MSPI - MSPI of this cluster member</li><li>Peer_MSPI - MSPI of cluster peer member</li></ul></li></ul></td></tr><tr><td><code>MSPI_req_connections</code></td><td><ul type="circle"><li>Used with <em>MSPI_requests</em> table. A packet that arrives for a connection that has issued a request for an MSPI, either because it does not exist, or the underlying SA is expired, is dropped.</li><li>Entries are entered to this table when the first request is issued for an MSPI for a connection.</li><li>Default expiration time is 60 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol; Timeout</em>&gt;, where:<br><ul type="square"><li>Source_IP - The source IP address</li><li>Dest_IP - The destination IP address</li><li>Source_Port - The source port</li><li>Dest_Port - The destination port</li><li>Protocol - Protocol number</li><li>Timeout - How much time remained to expiration time</li></ul></li></ul></td></tr><tr><td><code>MSPI_requests</code></td><td><ul type="circle"><li>Holds a linked list of packet IDs, which are on hold for an MSPI.</li><li>This table records deferred packets, one per connection, which require an MSA that has not been received.</li><li>Default expiration time is 60 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>MSPI; PktIDList</em>&gt;, where:<br><ul type="square"><li>MSPI - MSPI on this VPN peer</li><li>PktIDList - linked list of packet IDs</li></ul></li></ul></td></tr><tr><td><code>outbound_SPI</code></td><td><ul type="circle"><li>Contains all Outbound IPSec SAs.</li><li>This table stores MSPI and initiator cookie. These value are accessed according to peer and SPI.</li><li>Default expiration time is 3600 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_IP, OutSPI; MSPI, CookieI, CookieR, SA_ID, UserPeerID, Cluster_Member_IP; Timeout</em>&gt;, where:<br><ul type="square"><li>Peer_IP - The IP address of VPN peer</li><li>OutSPI - Outbound SPI</li><li>MSPI - The MSPI, with which this outbound SA is associated</li><li>CookieI - initiator cookie - helps identify the IKE SA used to negotiate the SA (this is useful when SA is about to expire and we want to renew it simply by employing IKE Phase 2 negotiation) (8 bytes in host byte order)</li><li>CookieR - responder cookie (8 bytes in host byte order)</li><li>SA_ID - outbound SA ID (it is <em>not</em> synchronized in Load Sharing mode, but created separately on each cluster member)</li><li>UserPeerID - user peer ID</li><li>Cluster_Member_IP - The IP address of cluster member that wrote the table entry</li><li>Timeout - How much time remained to expiration time</li></ul></li></ul></td></tr><tr><td><code>peer2ike</code></td><td><ul type="circle"><li>Holds Peer-to-IKE mappings for cookies.</li><li>No expiration time.</li><li>Not synchronized between cluster members.</li></ul></td></tr><tr><td><code>peers_count</code></td><td><ul type="circle"><li>Used store all the Gateway-to-Gateway peers, with which the local gateway maintains IPsec tunnels.</li><li>The table is mainly used by the licensing of VPN - to enforce the licensed number of IPsec tunnels.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Peer_IP; Ref_Count</em>&gt;, where:<br><ul type="square"><li>Peer_IP - The IP address of VPN peer</li><li>Ref_Count - Number of MSPIs with this VPN peer</li></ul></li></ul></td></tr><tr><td><code>persistent_tunnels</code></td><td><ul type="circle"><li>Holds MSPIs of persistent IPsec tunnels.</li><li>This kernel table is related to "<em>persistent_tunnels_ranges</em>" table that is defined in <em>$FWDIR/lib/user.def</em> file on the Management Server (refer to <a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk98239" target="_blank" rel="noopener">sk98239</a>).</li><li>Default expiration time is 600 seconds.</li><li>Not synchronized between cluster members.</li></ul></td></tr><tr><td><code>rdp_dont_trap</code></td><td><ul type="circle"><li>The VPN kernel picks up RDP packets on the outbound direction of the external interface. If the RDP packets carry an encryption command, this may lead to trapping the vpnd daemon. When a vpnd daemon is trapped for the RDP request, this is marked, to avoid sending multiple traps on the same issue.</li><li>Default expiration time is 60 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Source_IP, Tag</em>&gt;, where:<br><ul type="square"><li>Source_IP - The source IP address as appears in the RDP packet</li><li>Tag - The tag that is found in the RDP packet header</li></ul></li></ul></td></tr><tr><td><code>rdp_table</code></td><td><ul type="circle"><li>Holds RDP connections in the following specific case: when two VPN peers perform encryption with one another, and there is a Security Gateway in the middle that needs to forward these RDP connections.</li><li>All RDP connections are inserted into this table on that Security Gateway in the middle.</li><li>Default expiration time is 60 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry is:<br>either<br>&lt;<em>Source_IP, Source_Port, Dest_IP, Dest_Port, Protocol</em>&gt;<br>or (format used by Remote Access clients)<br>&lt;<em>Source_IP, Dest_IP</em>&gt;<br>where:<br><ul type="square"><li>Source_IP - The source IP address as appears in the RDP packet</li><li>Source_Port - The source port as appears in the RDP packet</li><li>Dest_IP - The destination IP address as appears in the RDP packet</li><li>Dest_Port - The destination port as appears in the RDP packet</li><li>Protocol - Protocol number as appears in the RDP packet</li></ul></li></ul></td></tr><tr><td><code>resolved_link</code></td><td><ul type="circle"><li>This table holds the resolved link to the peer gateway.</li><li>The data in the table is always updated, i.e., the resolved link is always the best known alive link.</li><li>The resolved link is calculated using one of the following mechanisms: Single IP for VPN, topology calculation, DNS resolution, one time RDP probing, ongoing RDP probing (the probing is performed in the vpnd daemon).</li><li>Each one of the above configurations defined on the peer object can be combined with multi-homed configuration defined on the resolving initiator's object.</li><li>Note that the resolved link and the source IP address are updated at the end of successful IKE in case the resolving configuration is final and 'reply from same IP' is configured.</li><li>The peer's status (unknown, alive, or dead) is also set in this table (the status is known in multi-homed and in ongoing probing configurations).</li><li>Default expiration time is 2147483647 seconds (2<sup>31</sup>-1), i.e., never expires.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Peer_IP; Source_IP, Dest_IP, Source IF, NextHop_IP, ExpectedPeer_IP, ExpectedPeer_Port, Flag, Status</em>&gt;, where:<br><ul type="square"><li>Peer_IP - The main IP address of peer gateway</li><li>Source_IP - The source IP address set on the packet</li><li>Dest_IP - The destination IP address of resolved link to the peer gateway</li><li>Source IF - The source interface of resolved link to the peer gateway ("-1" if multi-homed is not used)</li><li>NextHop_IP - The next hop IP of resolved link to the peer gateway ("0" if multiple ISP is not used)</li><li>ExpectedPeer_IP - The expected IP address of the peer gateway</li><li>ExpectedPeer_Port - The expected port on the peer gateway</li><li>Flag - "1" = the resolved link is final, "0" = the resolved link may change</li><li>Status - Status of a link (0=unknown, 1=alive, or 2=dead)</li></ul></li></ul></td></tr><tr><td><code>Sep_my_IKE_packet</code></td><td><ul type="circle"><li>Used for IKE forwarding in Load Sharing mode clusters.</li><li>If one cluster member initiates IKE negotiation, and another cluster member receives the answer, the IKE packet should be forwarded to the cluster member that initiated the IKE negotiation.</li><li>This table holds the IKE Initiator cookie including IKE Message ID (Message ID "0" means this is IKEv1 Phase 1).</li><li>When sending the IKE packet, the table is checked. If no entry exists, a new entry is set, and the table is synchronized.</li><li>When receiving the IKE packet, the table is checked. If no entry exists, the entry is set. Otherwise, the packet belongs to another cluster member, so it is forwarded according to the addresses set in the table.</li><li>Default expiration time is 120 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>CookieI, Message_ID; Cluster_Peer, IKE_Peer</em>&gt;, where:<br><ul type="square"><li>CookieI - initiator cookie of the IKE negotiation (8 bytes in host byte order)</li><li>Message_ID - Message ID of the IKE negotiation</li><li>Cluster_Peer - Cluster member that handled the first IKE packet of this IKE negotiation</li><li>IKE_Peer - the VPN peer, with whom the cluster is performing IKE negotiation</li></ul></li></ul></td></tr><tr><td><code>SPI_requests</code></td><td><ul type="circle"><li>Used by the VPN kernel to mark requests for SPI on behalf of a connection.</li><li>Requests for SPI result in IPsec SA negotiation, or renegotiation.</li><li>It is not necessary to trap the vpnd daemon more than once. The vpnd daemon is checked to see if it was already trapped for SPI, by querying this table.</li><li>This table is manipulated for scenarios where an SA is about to expire, already expired, or an SPI is received for which there is no SA yet. This can happen if packets arrive with an SPI, for which the daemon hasn't updated the tables with the corresponding SPI-to-SA.</li><li>Default expiration time is 60 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Source_IP, SPI, SA_Type</em>&gt;, where:<br><ul type="square"><li>Source_IP - The source IP address</li><li>SPI - The SPI request</li><li>SA_Type - Indicates whether it is IPSEC_AH_SA or IPSEC_ESP_SA request</li></ul></li></ul></td></tr><tr><td><code>udp_enc_cln_table</code></td><td><ul type="circle"><li>Maintains a list of the destination ports and the IP address used for UDP encapsulation.</li><li>UDP encapsulation is agreed on during SA negotiation in the IKE daemon (vpnd).</li><li>When decrypting UDP encapsulated packet, the Security Gateway saves the port and the IP address of UDP packet for using it in encrypting process.</li><li>The parameters are saved on the MSPI, and when encrypting the outbound packet, the port and the IP address will be set on the UDP packet.</li><li>In cluster, the parameters should be synchronized to all cluster members. Since MSA is not synchronized, the parameters will be set in this table. The cluster members, during post-sync, will find the local MSPI according to the key of the table and will set the port and IP address into the local MSPI.</li><li>The values are entered to the table during decryption whenever the port and IP address are changed on the MSA. Therefore, there is always a fresh instance of the destination port for the encapsulating UDP packets.</li><li>Default expiration time is 900 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>MSPI, GW_IP; Source_Port, NAT_IP</em>&gt;, where:<br><ul type="square"><li>MSPI - The MSPI on the cluster member</li><li>GW_IP - The IP address of Gateway that set the entry</li><li>Source_Port - The source port that the client uses</li><li>NAT_IP - The NATed IP address that is used for encapsulation (peer IP address)</li></ul></li></ul></td></tr><tr><td><code>udp_response_nat</code></td><td><ul type="circle"><li>Enables translation of outbound IKE and RDP packets, so that their source IP address appears to be the same as the destination IP address of the original packets (previous inbound from the same peer).</li><li>Default expiration time is 30 seconds.</li><li>Synchronized in cluster.</li><li>Table entry: &lt;<em>Peer_IP, Peer_Port; My_IP</em>&gt;, where:<br><ul type="square"><li>Peer_IP - The IP address of Security Gateway that assigned the IP address</li><li>Peer_Port - The source port of IKE or RDP request</li><li>My_IP - My IP address, taken from the inbound packet</li></ul></li></ul></td></tr><tr><td><code>VIN_SA_to_delete</code></td><td><ul type="circle"><li>Holds the IPsec NIC SA data until the packet's reference countdown reaches 0.</li><li>Default expiration time is 30 seconds.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>VIN_SA_ID; NIC_Enc_Data</em>&gt;, where:<br><ul type="square"><li>VIN_SA_ID - Running index</li><li>NIC_Enc_Data - IPsec NIC encryption data</li></ul></li></ul></td></tr><tr><td><code>vpn_active</code></td><td><ul type="circle"><li>Maintains a flag indicating if the VPN module is active.</li><li>The table is created upon the initialization of the VPN module (policy installation).</li><li>No expiration time.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Active_Flag</em>&gt;, where:<br><ul type="square"><li>Active_Flag - "1" = active</li></ul></li></ul></td></tr><tr><td><code>vpn_routing</code></td><td><ul type="circle"><li>Holds all the possible ranges that were defined for all Security Gateways.</li><li>This table is used in inbound and outbound policy chains when handling the first packet, to determine the peer gateway (peer + IDs) for IKE negotiation.</li><li>Community properties provide the methods, and <em>MSPI_by_methods</em> table provides the MSPI.</li><li>No expiration time.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>Range_From, Range_To; Peer_GW, Allowed_Peers_Table_ID, GW_Conf, Community_ID, Subnet_Support, Range_From, Range_To</em>&gt;, where:<br><ul type="square"><li>Range_From - The range "from" IP address</li><li>Range_To - The range "to" IP address</li><li>Peer_GW - The peer gateway for this IP range</li><li>Allowed_Peers_Table_ID - Table ID of <em>allowed_peers</em> table</li><li>GW_Conf - Gateway configuration: Single gateway, MEP gateway, or DAIP gateway</li><li>Community_ID - The community ID common to the peer and installed on Security Gateway</li><li>Subnet_Support - is subnet supported</li><li>Range_From - The range "from" IP address</li><li>Range_To - The range "to" IP address</li></ul></li></ul></td></tr><tr><td><code>XPO_names</code></td><td><ul type="circle"><li>Used when extranet partners are defined. It maps, for each partner, the XPO_ID, a UUID that is automatically assigned to each partner in the extranet, to a string ID that is used internally to write the name of the partner in the logs.</li><li>This table is initialized during the first policy load, and is updated each time a new policy is installed.</li><li>No expiration time.</li><li>Not synchronized between cluster members.</li><li>Table entry: &lt;<em>XPO_ID; Log_ID</em>&gt;, where:<br><ul type="square"><li>XPO_ID - Extranet partner UUID</li><li>Log_ID - Log ID</li></ul></li></ul></td></tr></tbody></table>

-   **Virtual Private Network (VPN)** \- Technology that extends a private network across a public network, such as the Internet. It enables a computer or network-enabled device to send and receive data across shared or public networks as if it were directly connected to the private network, while benefiting from the functionality, security and management policies of the private network. A VPN is created by establishing a virtual point-to-point connection through the use of dedicated connections, virtual tunneling protocols, or traffic encryption.
-   _**Encryption**_ - Process of encoding messages or information in such a way that only authorized parties can read it. _To encrypt a packet_ - means changing the contents of the packet using a cipher, so that only entities that knows it will be able to restore the contents of the packet to its original form. The cipher is created using encryption keys.
-   _**Symmetric-key algorithm**_ - One key is used for both encryption and decryption of the information.
-   _**Asymmetric-key algorithm**_ - Public-key cryptography, also known as asymmetric cryptography, is a form of cryptography, in which each party has a pair of cryptographic keys - a public key and a private key.
    
    The private key is kept secret, while the public key may be widely distributed:
    
    1.  So that other parties can send traffic encrypted and have the assurance that only the holder of the private key can open it (as opposed to sharing our private data).  
        Note: Asymmetric encryption can thus be used for exchanging a symmetric key - the other party will generate it and send it to us encrypted with our public key.
    2.  If data is encrypted with a private key, other parties can have assurance that the data was encrypted by a specific entity - the only holder of the private key. This is not for confidentiality purposes, as potentially everyone may hold the public key that can decrypt the data, but, rather, for the purpose of a digital signature.
    
      
    The keys are related mathematically, but the private key cannot be practically derived from the public key. A message encrypted with the public key can be decrypted only with the corresponding private key.
-   _**Security Association (SA)**_ - Establishment of shared security attributes between two network entities to support secure communication. An SA may include attributes such as: cryptographic algorithm and mode; traffic encryption key; and parameters for the network data to be passed over the connection. The framework for establishing security associations is provided by the Internet Security Association and Key Management Protocol (ISAKMP). Protocols such as Internet Key Exchange and Kerberized Internet Negotiation of Keys provide authenticated keying material. An SA is a simplex (one-way channel) and logical connection which endorses and provides a secure data connection between the network devices.
-   _**Internet Protocol Security (IPsec)**_ - Protocol suite for securing Internet Protocol (IP) communications by authenticating and encrypting each IP packet of a communication session. IPsec includes protocols for establishing mutual authentication between agents at the beginning of the session and negotiation of cryptographic keys to be used during the session. IPsec uses cryptographic security services to protect communications over Internet Protocol (IP) networks.
    
    IPsec supports network-level peer authentication, data origin authentication, data integrity, data confidentiality (encryption), and replay protection. IPsec is an end-to-end security scheme operating in the Internet Layer of the Internet Protocol Suite, while some other Internet security systems in widespread use, such as Transport Layer Security (TLS) and Secure Shell (SSH), operate in the upper layers at Application layer. Hence, only IPsec protects any application traffic over an IP network.
    
    IPsec can be implemented in a host-to-host transport mode, as well as in a network tunneling mode:
    
    -   _Transport mode_ - Encrypting only the data layer of the original packet - only the payload of the IP packet is usually encrypted and/or authenticated. The routing is intact, since the IP header is neither modified nor encrypted. However, when the authentication header is used, the IP addresses cannot be translated, as this always will invalidate the hash value. The OSI Transport and OSI Application layers are always secured by hash, so they cannot be modified in any way (for example by translating the port numbers).  
        A means to encapsulate IPsec messages for [NAT traversal (NAT-T)](https://en.wikipedia.org/wiki/NAT_traversal) has been defined by RFC documents describing the NAT-T mechanism.  
        Summary:  
        -   Protects Layers 4-7.
        -   Keeps the original IP header.
        -   Protects a connection between VPN peers.
        -   Does not make sense for a perimeter gateway.
    -   _Tunnel mode_ - the entire IP packet is encrypted and/or authenticated. It is then encapsulated into a new IP packet with a new IP header.  
        Tunnel mode is used to create VPNs for network-to-network communications (e.g., between routers to link sites), host-to-network communications (e.g., remote user access) and host-to-host communications (e.g., private chat).  
        Tunnel mode supports NAT traversal (NAT-T).  
        Tunnel mode is used in Check Point Site-to-Site VPN and Check Point Client-to-Site VPN.  
        Summary:  
        -   Protects Layers 3-7.
        -   Adds an encapsulating IP header.
        -   Protects networks behind the VPN peers.
-   _**Encapsulating Security Payload (ESP)**_ - Member of the IPsec protocol suite. In IPsec it provides origin authenticity, integrity and confidentiality protection of packets. ESP also supports encryption-only and authentication-only configurations.
    
    ESP operates directly on top of IP, using IP protocol number 50. ESP is a _portless_ protocol.  
    ESP header contains the SPI and Sequence Number that must be incremented (by 1 for every packet sent) to allow the VPN peer to defend itself from "Replay Attack".
-   _**NAT traversal (NAT-T)**, also known as **UDP Encapsulation**_ - Computer networking methodology with the goal to establish and maintain Internet protocol connections across gateways that implement network address translation (NAT). NAT traversal techniques are required for certain client-to-client network applications, such as peer-to-peer file sharing and Voice over IP. IPsec VPN clients use NAT-T in order to have Encapsulating Security Payload (ESP) packets traverse NAT.
    
    The ability to traverse NAT is achieved by UDP encapsulation of the ESP packets, which are portless by default.
    
    Using NAT-T will also encapsulate the IKE Quick Mode exchange packets, so they will be exchanged over UDP port 4500.
    
    To establish NAT-T, the initiator of the IKE negotiation must send a _NAT-D_ (NAT Discovery) payload (refer to [RFC 3947](https://tools.ietf.org/html/rfc3947#section-3.2) - Section 3.2) in the first packet and then the responder will do the same. This payload contains interface information to help the parties understand if their peer is behind NAT (if the source, from which the packets came is one of the peer's interfaces or not).
    
    Check Point VPN clients and SMB appliances (600/700/1100/1200R/1400/Edge), will initiate a negotiation with NAT-D payload, so NAT-T can be agreed on. However, Security Gateways currently support responding to negotiation with NAT-D payload, but do not initiate NAT-D themselves (The practical note is that if you have SMB appliance behind NAT - it should be behind _Hide_ NAT, so that the Central Gateway cannot initiate IKE connections to it, rather the Central Gateway would have to wait for the SMB appliance to start the IKE negotiation).
-   _**IPsec SA**_ - The IP security architecture uses the concept of a security association as the basis for building security functions into IP. A security association is simply the bundle of algorithms and parameters (such as keys) that is being used to encrypt and authenticate a particular flow in one direction. In short, IPsec SA is a set of encryption and decryption keys, as well as other information that identifies the VPN tunnel. Therefore, in normal bi-directional traffic, the flows are secured by a pair of security associations.
-   _**Security Parameter Index (SPI)**_ - Identification tag added to the header while using IPsec for tunneling the IP traffic. This tag helps the kernel discern between two traffic streams where different encryption rules and algorithms may be in use.  
    The SPI (as per [RFC 2401](https://tools.ietf.org/html/rfc2401)) is an essential part of an IPsec Security Association (SA) because it enables the receiving system to select the SA under which a received packet will be processed. An SPI has only local significance, since it is defined by the creator of the SA; an SPI is generally viewed as an opaque bit string. However, the creator of an SA may interpret the bits in an SPI to facilitate local processing.  
    In order to decide what protection is to be provided for an outgoing packet, IPsec uses the SPI, an index to the security association database (SADB), along with the destination address in a packet header, which together uniquely identify a security association for that packet. A similar procedure is performed for an incoming packet, where IPsec gathers decryption and verification keys from the security association database.
-   _**MSPI**_ - "Meta SPI" = peer + methods + IDs.
    
    -   MSPI is not a standard concept and exists only in Check Point VPN kernel.
    -   MSPI is actually a tunnel identifier. It is a local counter that uniquely identifies a tunnel on the _given_ machine.  
        In cluster topology it needs to be translated from the MSPI of peer cluster member to the local MSPI.
    -   MSPI is an index to the MSA (Meta SA), which contains fields common to all SAs with the same peer, methods, IDs, where:  
        -   Peer - peer gateway IP address
        -   Methods - per rule (community) parameters
        -   IDs - client/server or their containing subnets
    -   When a new IPsec tunnel is established, a new MSPI is created by, it get the next free MSPI number, and the MSPI counter is increased.
    -   When an IPsec tunnel is closed, the MSPI counter is decreased.
-   _**MSA**_ - "Meta SA".
    
    -   Contains:  
        -   Methods
        -   Encapsulation scheme (ESP, AH, UDP)
        -   Encryption algorithm
        -   Data integrity algorithm
        -   Peer identity
        -   Peer address
        -   User name (for Remote Access client)
        -   Intended use (IPsec IDs)
        -   Access to Current usable SA (outbound only)
    -   MSA is bi-directional.
    -   Inbound SAs point to the MSA.
    -   The MSA points to an outbound SA.
    -   When SAs are rekeyed and replaced, the MSA is not. It is just updated.
    -   An encrypted connection is marked with an MSPI (handle for the MSA).
-   **Internet Key Exchange (IKE)** - Protocol used to set up a Security Association (SA) in the IPsec protocol suite. This process requires that the IPsec systems first authenticate themselves to each other and establish ISAKMP (IKE) shared keys. IKE builds upon the Oakley protocol and ISAKMP. IKE uses X.509 certificates for authentication - either pre-shared, or distributed using DNS (preferably with DNSSEC) and a Diffie-Hellman key exchange - to set up a shared session secret, from which cryptographic keys are derived. In addition, a security policy for every peer, which will connect must be manually maintained.
    
    All IKE packets are exchanged over UDP port 500. Some variations of the IKE protocol can be exchanged over TCP port 500.
    
    IKEv1 Phases (performed by _**vpnd**_ daemon):
    
    1.  **IKEv1 Phase 1** is where the two ISAKMP peers establish a secure, authenticated channel with which to communicate. This is called the ISAKMP Security Association (SA).
        
        The basic purpose of IKEv1 Phase 1 is to authenticate the IPsec peers and to set up a secure channel between the peers to enable IKEv1 exchanges. IKEv1 Phase 1 performs the following functions:
        
        -   Authenticates and protects the identities of the IPsec peers
        -   Negotiates a matching IKE SA policy between peers to protect the IKE exchange
        -   Performs an authenticated Diffie-Hellman exchange with the end result of having matching shared secret keys
        -   Sets up a secure tunnel to negotiate IKEv1 Phase 2 parameters
        
        This negotiation results in one single bi-directional ISAKMP Security Association (SA). The authentication can be performed using either pre-shared key (shared secret), signatures, or public key encryption.
        
        Phase 1 operates in either _Main Mode_ (protects the identity of the peers), or _Aggressive Mode_ (does not protect the identity of the peers):
        
        -   _Main Mode_ is an instantiation of the ISAKMP Identity Protect Exchange. Main Mode has 3 two-way exchanges between the initiator and the receiver:
            
            -   First exchange:  
                The 1st and the 2nd messages negotiate policy. The algorithms and hashes used to secure the IKE communications are agreed upon in matching IKE SAs in each peer.  
                The 1st message is sent from the VPN peer (_initiator_), which initiates the IKE SA negotiation to VPN peer (_responder_), with which the VPN tunnel should be established.
            -   Second exchange:  
                The 3rd and the 4th messages exchange Diffie-Hellman public values and ancillary data (e.g., nonces) necessary for the exchange. Uses a Diffie-Hellman exchange to generate shared secret keying material used to generate shared secret keys and to pass noncesârandom numbers sent to the other party and then signed and returned to prove their identity.
            -   Third exchange:  
                The 5th and the 6th messages authenticate the Diffie-Hellman Exchange. Verifies the other side's identity. The identity value is the IPsec peer's IP address in encrypted form. The main outcome of main mode is matching IKE SAs between peers to provide a protected pipe for subsequent protected ISAKMP exchanges between the IKE peers. The IKE SA specifies values for the IKE exchange: the authentication method used, the encryption and hash algorithms, the Diffie-Hellman group used, the lifetime of the IKE SA in seconds or kilobytes, and the shared secret key values for the encryption algorithms. The IKE SA in each peer is bi-directional.
            
            Main Mode packets:
            
            1.  MM packet 1 (sent in clear-text, not encrypted):  
                Contains one or more propositions for IKE SA methods, including key length and strength (i.e., AES-256 bit encryption), IKE SA hash algorithms for securing IKE packets, authentication method (usually shared secret or certificate, relevant for Main Mode packets 5 and 6), Diffie-Helman group range for public key creation, and IKE SA lifespan - how long this SA will be valid
            2.  MM packet 2 (sent in clear-text, not encrypted):  
                Contains the chosen proposition from the list of propositions offered in Main Mode packet 1
            3.  MM packet 3 (sent in clear-text, not encrypted):  
                Contains the public key of the VPN gateway, generated according to the Diffie-Helman group range, as well as a request for certificate signed by a trusted Certificate Authority (if authentication type is by using certificates, decided in Main Mode packet 1 and Main Mode packet 2)
            4.  MM packet 4 (sent in clear-text, not encrypted):  
                Contains the public key of the VPN gateway - as well as a request for certificate signed by a trusted Certificate Authority (if authentication type is by using certificates, decided in Main Mode packet 1 and Main Mode packet 2)
            5.  MM packet 5 (sent encrypted using the IKE SA):  
                Used to authenticate the VPN peers to each other. Contains the authentication method (certificate-based or shared-secret based), and the authentication details themselves (a certificate or the shared passphrase).  
                Also contains _ID_ field used for identification, in addition to the certificate/passphrase - ID is either the IP address, or the FQDN of the VPN gateway, which sent the packet (this field is _not_ used by Check Point; but can be used by some 3rd party vendors).  
                -   If the IKE SA is authenticated using certificate, then MM packet 5 contains the VPN gateway's certificate and CRL list, if the VPN gateways authenticate to each other using a certificate signed by different CAs.
                -   If the IKE SA is authenticated using shared secret, then in MM packet 5 the shared secret configured on each VPN gateway will be used.
            6.  MM packet 6 (sent encrypted using the IKE SA):  
                Contains the same data as MM packet 5.
        -   _Aggressive Mode_ is an instantiation of the ISAKMP Aggressive Exchange. In Aggressive Mode, fewer exchanges are made, and with fewer packets. On the first exchange, almost everything is squeezed into the proposed IKE SA values: the Diffie-Hellman public key; a nonce that the other party signs; and an identity packet, which can be used to verify identity via a third party. The receiver sends everything back that is needed to complete the exchange. The only thing left is for the initiator to confirm the exchange. The weakness of using the Aggressive Mode is that both sides have exchanged information before there is a secure channel. Therefore, it is possible to "sniff" the wire and discover who formed the new SA. However, it is faster than Main Mode.
            
            Messages:
            
            -   1st and the 2nd messages:  
                Negotiate policy, exchange Diffie-Hellman public values and ancillary data necessary for the exchange, and identities. In addition, the 2nd message authenticates the responder.
            -   3rd message:  
                Authenticates the initiator and provides a proof of participation in the exchange.
    2.  **IKEv1 Phase 2** is where Security Associations are negotiated on behalf of services such as IPsec or any other service, which needs key material and/or parameter negotiation.
        
        During IKEv1 Phase 2, the IKE peers use the secure channel established in IKEv1 Phase 1 to negotiate Security Associations on behalf of other services like IPsec. The negotiation results in a minimum of two unidirectional Security Associations - one _inbound_ and one _outbound_:
        
        -   Inbound SA: How do I decrypt packets coming to me from the VPN peer?
        -   Outbound SA: How do I encrypt packets going from me to the VPN peer?
        
        IKEv1 Phase 2 performs the following functions:
        
        -   Negotiates IPsec SA parameters protected by an existing IKE SA
        -   Establishes IPsec security associations
        -   Periodically renegotiates IPsec SAs to ensure security
        -   Optionally performs an additional Diffie-Hellman exchange
        
        IKEv1 Phase 2 has one mode, called _Quick Mode_, which occurs after IKE has established the secure tunnel in IKEv1 Phase 1. It negotiates a shared IPsec policy, derives shared secret keying material used for the IPsec security algorithms, and establishes IPsec SAs. Quick Mode exchanges nonces that provide replay protection. The nonces are used to generate new shared secret key material and prevent replay attacks from generating bogus SAs:
        
        1.  Quick Mode packet 1:  
            Contains one or propositions for IPsec SA. Similar to the Main Mode packet 1, here the VPN gateway proposes the key length and encryption type. By default, the key used in the IPsec SA is symmetric, but can be asymmetric, when Perfect Forward Secrecy (PFS) is enabled. If it is, than the keys will be asymmetric - and QM packet 1 will contain, similar to MM packet 1, a Diffie-Helman group type and a public key from that group. A hash algorithm proposal will also be sent. In addition to encryption details and methods, the QM contains subnet (IDs) of the hosts, to which that data should be encrypted / from which the data should be decrypted.
        2.  Quick Mode packet 2:  
            Contains the chosen proposition from the list of propositions offered in QM packet 1. By default, it also contains a symmetric key length and type, which the peer chose from the proposed list in QM 1 (i.e., AES 256-bit). If Perfect Forward Secrecy (PFS) is enabled, then the public key is sent here. In addition to encryption details and methods, the QM contains subnet (IDs) of the hosts, to which that data should be encrypted / from which the data should be decrypted.
        3.  Quick Mode packet 3:  
            Contains no real data; used for acknowledgment.
        
        Quick Mode is also used to renegotiate a new IPsec SA when the IPsec SA lifetime expires. Base Quick Mode is used to refresh the keying material used to create the shared secret key based on the keying material derived from the Diffie-Hellman exchange in IKEv1 Phase 1.
        
        Like the IKE SA, the IPsec SAs are unique between a pair of VPN gateways.
    
    Improvements with IKEv2:
    
    -   Fewer RFCs
    -   Standard Mobility support
    -   NAT traversal
    -   SCTP support
    -   Simple message exchange
    -   Fewer cryptographic mechanisms
    -   Reliability and State management
    -   Denial of Service (DoS) attack resilience
    
    RFC:
    
    -   For IKEv1, refer to [RFC 2409](https://tools.ietf.org/html/rfc2409) and [RFC 4109](https://tools.ietf.org/html/rfc4109).
    -   For IKEv2, refer to [RFC 7296](https://tools.ietf.org/html/rfc7296) and [RFC 7427](https://tools.ietf.org/html/rfc7427).
-   _**IKE Security Association (IKE SA)**_ - Includes the following information:
    
    -   Encryption methods - key length and encryption algorithm - to use for encrypting the IPSEC SA negotiations - as well as type of hash algorithm for IKE packets authenticating
    -   Peer IP - with which VPN gateway this IKE SA is valid
    -   Authentication method - how the VPN gateways have authenticated to each other
    -   Lifespan (life duration) - for how long the IKE SA, in seconds, will be valid. When an IKE SA will expire, it will be deleted and never used again
    
      
    Unlike IPsec SAs, there can only be _one_ IKE SA between a pair of VPN peers (it is unique between the two VPN peers).
-   _**IKE Authentication Methods**_ - Authentication methods used by VPN peers to authenticate themselves to each other during the IKEv1 Main Mode (generation of an IKE SA) negotiation:
    
    -   _Pre-Shared Secret_: A mutual password or pass phrase, which is configured in each VPN gateway.
    -   _Certificate-based (RSA Signatures)_: Each VPN peer presents a certificate signed by a trusted Certificate Authority (CA).If the VPN peer trusts the CA, it will trust the VPN peer who presents a certificate signed by that CA. This is considered the most secured Authentication Method.
    -   _Hybrid Mode (Hybrid init-RSA)_: A combination of both, also known as "Challenge/Response". Used primarily for Remote Access VPN sessions - VPN between a remote user and a VPN gateway. The VPN gateway presents a certificate to the user to identify itself, while the client is allowed to authenticate via some other means, such as username/password, SecurID, etc.
-   _**Certificate**_ - Public key certificate (also known as a _digital certificate_ or _identity certificate_) is an electronic document used to prove ownership of a public key. The certificate includes information about the key, information about its owner's identity, and the digital signature of an entity that has verified the certificate's contents are correct. If the signature is valid, and the person examining the certificate trusts the signer, then they know they can use that key to communicate with its owner.
-   _**Certificate Authority**_ - an entity that issues digital certificates. A digital certificate certifies the ownership of a public key by the named subject of the certificate. This allows others (relying parties) to rely upon signatures or on assertions made by the private key that corresponds to the certified public key. In this model of trust relationships, a CA is a trusted third party - trusted both by the subject (owner) of the certificate and by the party relying upon the certificate.
    
    Every deployment of Check Point Security Management Server / Multi-Domain Security Management Server server includes an Internal Certificate Authority (ICA) that issues VPN certificates for the VPN Gateways it manages. These VPN certificates simplify the definition of VPNs between these gateways.
    
    If the Security Gateways use certificates, the certificates can be issued either by the Internal Certificate Authority (ICA) on the Security Management Server, or by a third party OPSEC certified CA.  
    The Internal CA makes it very easy to use PKI for Check Point applications such as site-to-site and remote access VPNs. However, an administrator may prefer to continue using a CA that is already used within the organization, for generalized applications such as secure email, and disk encryption.  
    If the Security Gateways are both internally managed and use certificates for authentication, the easiest strategy is for both Security Gateways to present a certificate signed by the Internal CA.
-   _**Certificate Revocation List (CRL)**_ - List of certificates (or more specifically, a list of serial numbers for certificates) that have been revoked, and therefore, entities presenting those (revoked) certificates should no longer be trusted. VPN can retrieve the CRL from either an HTTP server, or an LDAP server.
    
    Since the retrieval of CRL can take a long time (in comparison to the entire IKE negotiation process), VPN stores the CRLs in a CRL cache, so that later IKE negotiations do not require repeated CRL retrievals.  
    The cache is pre-fetched:  
    
    -   every two hours
    -   on policy installation
    -   when the cache expires
    
      
    If the pre-fetch fails, the previous cache is not erased.  
    Note: The ICA requires the use of a CRL cache, and should never be disabled.
-   _**Simple Certificate Enrollment Protocol (SCEP)**_ - Protocol used by numerous manufacturers of network equipment and software who are developing simplified means of handling certificates for large-scale implementation to everyday users, as well as being referenced in other industry standards.  
    The protocol is designed to make the issuing of digital certificates as scalable as possible. The idea is that any standard network user should be able to request their digital certificate electronically and as simply as possible. These processes have usually required intensive input from network administrators, and so have not been suited to large scale deployments.  
    SCEP is a Public Key Infrastructure (PKI) communication protocol used for communicating with Certificate Authorities. SCEP is the evolution of an enrollment protocol developed by VeriSign for Cisco Systems, and now enjoys wide support in both client and Certificate Authority implementations.  
    SCEP is the most popular, widely available and most tested certificate enrollment protocol.
-   _**Online Certificate Status Protocol (OCSP)**_ - Enables applications to identify the state of a certificate. OCSP may be used for more timely revocation information than is possible with CRLs and may also be used to obtain additional status information. When OCSP client issues a status request to an OCSP server, acceptance of the certificate in question is suspended until the server provides a response.  
    In order to use OCSP, the root CA must be configured to use this method instead of CRL. This setting is inherited by the subordinate CA's.
-   _**Perfect Forward Secrecy (PFS)**_ - Property of key-agreement protocols ensuring that a session key derived from a set of long-term keys cannot be compromised if one of the long-term keys is compromised in the future. The key used to protect transmission of data must not be used to derive any additional keys, and if the key used to protect transmission of data is derived from some other keying material, then that material must not be used to derive any more keys. In this way, compromise of a single key permits access only to data protected by that single key.  
    If PFS is specified in the IPsec policy, a new Diffie-Hellman exchange is performed with each Quick Mode, providing keying material that has greater entropy (key material life) and thereby greater resistance to cryptographic attacks. Each Diffie-Hellman exchange requires large exponentiations, thereby increasing CPU utilization and exacting a performance cost.
-   _**VPN Community**_ - Collection of VPN-enabled gateways capable of communicating via VPN tunnels (collection of VPN tunnels/links and their attributes).
-   _**VPN Community member**_ - VPN Gateway that resides at one end of a VPN tunnel.
-   _**VPN Site**_ - VPN Community member plus VPN Domain. A typical VPN site would be the branch office of a bank.
-   _**VPN Domain (Encryption Domain)**_ - Refers to the hosts behind the VPN Gateway. The VPN Domain can be either the whole network that lies behind the VPN Gateway, or just a section of that network:
    
    -   The whole network behind the VPN-1 Gateway or just a section of that network.
    -   Group of objects allowed to use VPN tunnel established by VPN-1 Gateway.
    -   Allowed to be accessed by external peers using VPN tunnel.
    -   Access to these objects is being managed by Security rulebase and VPN Community.
    
    The terms "VPN Domain" and "Encryption Domain" mean the same thing. Usually:
    
    -   "VPN Domain" is used in the context of Simplified Mode policies.
    -   "Encryption Domain" for Traditional Mode policies.
-   _**VPN Topology:**_
    
    -   _Meshed_ - VPN Community, in which VPN tunnels can be created between VPN gateway pairs. This means that every gateway communicates with every other gateway. Typical for Intranet gateways.
    -   _Star_ - VPN Community composed of two types of peer, Central (Hub) and Satellite (Spoke), where:
        -   Each central gateway can establish VPN tunnel with each satellite gateway
        -   Satellite gateways cannot establish VPN tunnels with each other
        -   Central gateways cannot establish VPN tunnel with each other by default, but this is configurable on the Central Gateways page
-   _**VPN Modes:**_
    
    -   _Simplified VPN Mode_ - Interactions between Check Point Security Gateways are defined through VPN Communities. Access Control between Check Point Security Gateways is defined with regular Firewall Rule Base. The "VPN" column in the security policy is used to specify connections that pass through Community Members.  
        Simplified Mode makes it possible to maintain and create simpler, and therefore less error prone and more secure VPNs.  
        Simplified Mode separates the VPN definitions from the Access Control Security Policy - the Security Rule Base deals only with access control. In other words, the Rule Base determines only what is allowed. VPN properties, on the other hand, are dealt with per VPN community. This makes it easier to understand the VPN topology of an organization, and to understand which users are allowed to securely communicate with each other.  
        In addition, _VPN Routing_ is supported only with a Simplified VPN Mode Security Policy.
    -   _Traditional VPN Mode_ - VPN attributes are defined on the Check Point Security Gateways and Access Control between Check Point Security Gateways is configured by the rules governing encryption in the Firewall Rule Base. A single rule, with the "Encrypt" rule action, deals with both access control and encryption. VPN properties are defined per Security Gateway.  
        Traditional policies allow VPNs to be created with greater granularity than Simplified policies, because:  
        -   Whether or not to encrypt can be defined per rule (source, destination and service).
        -   Simplified policies requires all the connections between two Security Gateways to encrypted using the same methods, using the Community definitions.
-   _**Link Selection**_ - Method used to determine which interface is used for incoming and outgoing VPN traffic as well as the best possible path for the traffic.
    
    Link Selection mechanism helps the administrator define how two peer VPN gateways find the path to establishing a tunnel between them. Link Selection was designed to answer these questions:
    
    1.  Which IP address of the peer gateway should be used to establish the tunnel?
    2.  Which interface and next hop gateway should be used to reach that IP address?
    3.  Which IP address of the local gateway should be used as the source IP on the outgoing tunneled traffic (i.e. the encapsulating tunnel headers and tunnel establishment packets)?
    
      
    Link Selection has many configuration options to enable you to control VPN traffic.  
    Note: The administrator can choose, which IP addresses are used for _IKE_ and _RDP_ traffic, but not for the actual encrypted traffic (ESP).
-   _**VPN Routing**_ - Way of directing communication through a specific VPN tunnel in order to enhance existing connectivity or security. In addition, VPN routing can be used to reduce connectivity costs.
    
    -   _Domain Based VPN_ - VPN traffic is routed within the VPN community based on the encryption domain behind each Security Gateway in the community.  
        In a Star community, this allows satellite Security Gateways to communicate with each other through central Security Gateways.  
        Configuration for Domain Based VPN is performed directly through SmartDashboard.
    -   _Route Based VPN_ - VPN traffic is routed within the VPN community based on the routing information, static or dynamic, configured on the Operating Systems of the Security Gateways.
    
    SmartDashboard configuration allows routing the traffic between Satellites via the Center and between Satellites and the Internet (route all traffic via the center). "Manual" routing configuration is available via the _$FWDIR/conf/vpn\_route.conf_ file on the Security Management Server.
    
    Notes:
    
    -   VPN Routing is supported only with a Simplified VPN Mode Security Policy.
    -   If both Domain Based VPN and Route Based VPN are configured, then _Domain Based VPN_ will take precedence.
-   _**$FWDIR/conf/vpn\_route.conf**_ - configuration file on Security Management Server / Domain Management Server used for granular control over Domain Based VPN routing between Security Gateways.
    
    Notes:
    
    -   The file format is: _Destination_, _Next hop router_, _Install on Security Gateway_, _Force Override_ (optional field)
    -   Fields must be separated by _tabs_.
    -   All entries must be objects that exist in the Management database. The names must match object names exactly.
-   _**Directional VPN**_ - VPN Match Condition in security policy that enables VPN traffic in one direction only.
-   _**Internally Security Gateway and Externally Managed Security Gateway**_ - The Security Gateways at each end of a VPN tunnel can be managed by the same Security Management Server or by different Security Management Servers:
    
    -   A Security Gateway that is managed by the given Security Management Server is called an _internal_ Security Gateway.
    -   A Security Gateway that is managed by a different Security Management Server is called an _external_ Security Gateway.
-   _**Permanent Tunnel**_ - VPN tunnel that is constantly kept active and as a result, make it easier to recognize malfunctions and connectivity problems. Administrators can monitor the two sides of a VPN tunnel, and identify problems without delay.
-   _**Tunnel Testing**_ - Check Point uses a proprietary protocol to test if VPN tunnels are active, and supports any Site-to-Site VPN configuration. Tunnel testing requires two Security Gateways, and uses UDP port 18234.  
    Note: Check Point tunnel testing protocol is supported only by Check Point gateway.  
    Tunnel Testing protocol packet types:  
    -   Tunnel Test (type 1) - "ping" (if RIM is configured, then this packet tells the MEP member that it is the "chosen one", so it knows to inject the routes accordingly)
    -   Tunnel Test Reply (type 2) - reply to the "ping"
    -   Tunnel Test Connect (type 3) - used to initiate IKE by SecuRemote/SecureClient
    -   Tunnel Test Connected (type 4) - indicates tunnel establishment
-   _**Dead Peer Detection (DPD)**_ - In addition to _Tunnel Testing_, Dead Peer Detection (DPD) is a different method to test if VPN tunnels are active. Dead Peer Detection does support 3rd party Security Gateways and supports Permanent Tunnels with interoperable devices based on either IKEv1 DPD (based on [RFC 3706](https://tools.ietf.org/html/rfc3706)), or IKEv2 DPD. It uses IPsec traffic patterns to minimize the number of messages required to confirm the availability of a peer.
    
    The Tunnel Testing mechanism is the recommended keepalive mechanism for "Check Point"-to-"Check Point" VPN gateways because it is based on IPsec traffic and requires an IPsec established tunnel. DPD is based on IKE encryption keys only.
    
    DPD has two modes:
    
    -   _DPD responder mode_ - Check Point gateway sends the IKEv1 DPD Vendor ID to VPN peers, from which the DPD Vendor ID was received.
    -   _Permanent tunnel mode based on DPD_ - DPD can monitor remote peers with the permanent tunnel feature. All related behavior and configurations of permanent tunnels are supported.  
        To configure DPD for a permanent tunnel, the permanent tunnel must be in the VPN community. After you configure the permanent tunnel, configure Permanent Tunnel mode Based on DPD.  
        There are different possibilities for permanent tunnel mode:  
        
        -   _tunnel\_test_ (default) - The permanent tunnel is monitored by Tunnel Test (as in earlier versions). It works between Check Point gateways only. Keepalive packets are always sent.
        -   _dpd_ - The active DPD mode. A VPN peer receives DPD requests at regular intervals (10 seconds). DPD requests are only sent when there is no traffic from the VPN peer.
        -   _passive_ - The passive DPD mode. VPN peers do not send DPD requests to this VPN peer. Tunnels with passive peers are monitored only if there is IPsec traffic and incoming DPD requests.
        
          
        Notes:  
        -   Requires a Security Gateway R77.10 and higher.
        -   Requires a Security Management Server / Multi-Domain Security Management Server R77.10 and higher.
        -   This feature is supported in R75.40VS with LTE Hotfix / R76 with LTE Hotfix.
        -   To use this mode for only some gateways, enable the DPD Responder Mode on Check Point remote peers.
-   _**Route Injection Mechanism (RIM)**_ - Enables a Security Gateway to use a Dynamic Routing protocol to propagate the encryption domain of a VPN peer Security Gateway to the internal network. When a VPN tunnel is created, RIM updates the local routing table of the Security Gateway to include the encryption domain of the VPN peer.
    
    RIM is used to:
    
    -   Route return packets through the correct VPN link or VPN gateway
    -   Overcome VPN link down time
    
    RIM is based both on the ability of the Security Gateway to update its local routing table, and the presence of the a Dynamic Routing protocol to distribute the change to the network behind the Security Gateway. There is little sense in enabling RIM on the Security Gateway if a Dynamic Routing protocol is not available to distribute changes.
    
    For example, when a VPN link becomes unavailable, an alternative path is added or "injected" to the local routing table on the VPN gateway. If a Dynamic Routing protocol is then configured, this change is propagated to the network behind the VPN gateway. Route injection can be integrated with MEP functionality, providing an alternative to IP Pool NAT in situations where large numbers of static IP addresses are not available.
    
    There are two possible methods to configure RIM:
    
    -   _Automatic RIM_ - RIM automatically injects the route to the encryption domain of the peer Security Gateways.
    -   _Custom Script_ - Specify tasks for RIM to perform according to specific needs.
    
    Injecting Peer Security Gateway Interfaces (the _RIM\_inject\_peer\_interfaces_ flag) is used to inject into the routing tables the IP addresses of the peer Security Gateway in addition to the networks behind the Security Gateway.
    
    Notes:
    
    -   Route Injection is _not_ supported with 3rd party gateways.
    -   Route Injection is _not_ currently supported for IPv6.
    -   RIM is _not_ available when MEP Selection Method is set to "Random Selection".
-   _**Single Entry Point (SEP) VPN**_ - There is a single entry point from the Internet to the internal network, at which two or more Security Gateways are situated (these Security Gateways are members of a cluster with enabled state synchronization).
    
    SEP VPN provides a High Availability and Load Sharing solution for VPN connections at single entry point.
-   _**Multiple Entry Points (MEP) VPN**_ - There are multiple geographically-separated entry points from the Internet to the internal networks, with a Security Gateway at each entry point.
    
    MEP VPN provides a High Availability and Load Sharing solution for VPN connections. Integral part of a VPN Star community. Any Star Community with more than one central gateway can enable MEP, providing multiple entry points to the core network behind the VPN gateways.
    
    There are four MEP Selection Methods of selecting to entry point to the core network:
    
    -   _First to Respond_ - Select the closest gateway to source - the first Security Gateway to reply to the peer Security Gateway is chosen.
    -   _VPN Domain_ - Select the closest gateway to destination - when the destination IP address belongs to a particular VPN domain, the Security Gateway of that domain becomes the chosen entry point.
    -   _Random Selection_ - different Security Gateway is randomly selected as an entry point for incoming traffic (for load distribution).
    -   _Manually set priority list_ - Security Gateway priorities can be set manually for the entire community or for individual satellite Security Gateways (MEP rules).
    
    MEP is implemented via a proprietary Check Point Reliable Datagram Protocol (RDP) packets sent to UDP port 259 to discover whether an IP address is reachable (these UDP RDP packets are not encrypted, and only test the availability of a peer). This protocol does _not_ conform to RDP as specified in RFC 908/1151. The _**vpnd**_ daemon is in charge of the probing and path choosing operations.
    
    There are two available methods to implement MEP:
    
    -   _Explicit MEP_ - Only Star communities with more than one central Security Gateway can enable explicit MEP, providing multiple entry points to the network behind the Security Gateways. When available, Explicit MEP is the recommended method.  
        In a site to site Star VPN community, explicit MEP is configured via the community object. When MEP is enabled, the satellites consider the "unified" VPN domain of all the Security Gateways as the VPN domain for each Security Gateway. This unified VPN domain is considered the VPN domain of each Security Gateway.  
        Explicit MEP supports four MEP Selection Methods:  
        -   First to Respond
        -   VPN Domain
        -   Random Selection
        -   Manually set priority list
    -   _Implicit MEP_ - Implicit MEP is supported in all scenarios where fully or partially overlapping encryption domains exist or where Primary-Backup Security Gateways are configured.  
        Implicit MEP is supported if the Security Gateways with overlapping encryption domains are in the same community. If they are located in different communities, only one of the Security Gateways will be used for this encryption domain.  
        Implicit MEP supports three MEP Selection Methods:  
        -   First to Respond
        -   Primary-Backup
        -   Load Distribution (Random Selection)
-   _**IP Pool NAT**_ - Type of NAT, in which source IP addresses from remote VPN domains are mapped to an IP address drawing from a pool of registered IP addresses.  
    In order to maintain symmetric sessions using MEPed Security Gateways, the MEPed Security Gateway performs NAT using a range of IP addresses dedicated to that specific Security Gateway and should be routed within the internal network to the originating Security Gateway.  
    When the returning packets reach the Security Gateway, the Security Gateway restores the original source IP address and forwards the packets to the source.
-   _**Wire Mode**_ - Allows traffic to be encrypted, but avoid inspection between peers of the VPN community. Using Wire Mode, the FireWall can be bypassed for VPN connections by defining internal interfaces and communities as "trusted".
    
    When a packet reaches a Security Gateway, the Security Gateway asks itself two questions regarding the packet(s):
    
    -   Is this information coming from a "trusted" source?
    -   Is this information going to a "trusted" destination?
    
      
    If the answer to both questions is _yes_, and the VPN Community to which both Security Gateways belong is designated as "Wire Mode enabled", stateful inspection is not enforced and the traffic between the trusted interfaces bypasses the firewall. Since no stateful inspection takes place, no packets can be discarded.
-   _**Large Scale VPN (LSV)**_ - Lets the administrator define a VPN with many VPN peers without defining a network object for each VPN peer. Administrator defines one LSV Profile for all potential VPN peers. It is possible to create more than one LSV profile, one for each CA. The LSV Profile and the Security Gateways must be members of the same VPN community.  
    (Note: Refer to section "Limitations related to VPN")
-   _**VPN Tunnel Interface (VTI)**_ - Virtual Interface on a Security Gateway that is related to a VPN tunnel and connects to a remote VPN peer. You create a VTI on each Security Gateway that connects to the VTI on a remote VPN peer. Traffic routed from the local Security Gateway via the VTI is transferred encrypted to the associated peer Security Gateway.
    
    A Virtual Interface behaves like a Point-to-Point interface directly connected to the remote VPN peer. Traffic between network hosts is routed into the VPN tunnel using the IP routing mechanism of the Operating System.  
    Security Gateway objects are still required, as well as VPN communities (and access control policies) to define which tunnels are available. However, VPN encryption domains for each peer Security Gateway are no longer necessary. The decision whether or not to encrypt depends on whether the traffic is routed through a virtual interface.  
    The routing changes dynamically if a dynamic routing protocol (OSPF/BGP) is available on the network.
    
    The VTI can be configured in two ways:
    
    -   _Numbered_ - Local IP address and remote IP address are configured for each numbered VPN Tunnel Interface (VTI). For each Security Gateway, the following are configured: a local IP address, a remote address, and the local IP address source for outbound connections to the tunnel. The remote IP address must be the local IP address on the remote peer Security Gateway. More than one VTI can use the same IP Address, but they cannot use an existing physical interface IP address.
    -   _Unnumbered_ - For unnumbered VTIs, a proxy interface is defined for each Security Gateway. Each Security Gateway uses the proxy interface IP address as the source for outbound traffic. Unnumbered interfaces let administrator assign and manage one IP address for each interface. Proxy interfaces can be physical or loopback interfaces.
    
    VTIs allow the ability to use Dynamic Routing Protocols to exchange routing information between Security Gateways. The supported Dynamic Routing Protocols are:
    
    -   OSPF
    -   BGP4
    
    For more information, see the [Gaia Administration Guide](https://support.checkpoint.com/product/73) for the relevant version > "Network Management" > "Network Interfaces" > "VPN Tunnel Interfaces".
    

<table><tbody><tr><td>Feature / Configuration</td><td>Limitation</td></tr><tr><td>IPv6</td><td><ul type="circle"><li>Refer to <a href="https://sc1.checkpoint.com/documents/R77/CP_R77_VPN_AdminGuide/13868.htm#o95044" target="_blank" rel="noopener">this list</a>.</li><li>On 40000 / 60000 Security System with VPN, you must configure IPv6 for at least one interface when IPv6 is enabled.</li></ul></td></tr><tr><td>VPN Routing</td><td><ul type="circle"><li>Supported <em>only</em> with a Simplified VPN Mode Security Policy.</li></ul></td></tr><tr><td>Traditional Mode VPN</td><td><ul type="circle"><li><em>Not</em> supported by CoreXL (if configured in SmartConsole, then CoreXL acceleration will be automatically disabled on the Security Gateway).</li><li><em>Not</em> supported on 40000 / 60000 Security System.</li><li><em>Not</em> supported in 1100 / 1200R / 1400 appliances running R77.20.X firmware (applies only to Centrally Managed).</li></ul></td></tr><tr><td>Check Point Tunnel Testing protocol</td><td><ul type="circle"><li>Supported <em>only</em> for Check Point gateways and appliances.</li></ul></td></tr><tr><td>Externally managed Check Point gateway</td><td><ul type="circle"><li>In VPN with an externally managed Check Point gateway with disabled "supernetting", IPsec SA is created per host, but not per-subnet.</li></ul></td></tr><tr><td>Dead Peer Detection (DPD)</td><td><ul type="circle"><li>In "<em>Permanent tunnel mode based on DPD</em>" mode:<br><ul type="square"><li>Requires a Security Gateway R77.10 and higher.</li><li>Requires a Security Management Server / Multi-Domain Security Management Server R77.10 and higher.</li><li>This feature is supported in R75.40VS with LTE Hotfix / R76 with LTE Hotfix.</li></ul></li><li><em>Not</em> supported in 600 / 700 / 1100 / 1200R / 1400 appliances running R75.20.X / R77.20.X firmware (applies to both Locally and Centrally Managed).</li></ul></td></tr><tr><td>Route Injection Mechanism (RIM)</td><td><ul type="circle"><li>RIM is <em>not</em> supported with 3rd party gateways.</li><li>RIM is <em>not</em> supported for IPv6.</li><li>RIM is <em>not</em> available when MEP Selection Method is set to "Random Selection".</li></ul></td></tr><tr><td>Large Scale VPN (LSV)</td><td><ul type="circle"><li>Supported in R81</li><li>Supported in R80.40</li><li>Not supported in R80.10, R80.20, and R80.30</li><li>Supported in R77.30.</li><li>Supported in R77.10 LTE Hotfix (<a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk100446" target="_blank" rel="noopener">sk100446</a>).</li><li>Supported in R76 LTE Hotfix (<a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk95768" target="_blank" rel="noopener">sk95768</a>).</li></ul></td></tr><tr><td>VPN Tunnel Interface (VTI)</td><td><ul type="circle"><li>Numbered VTI is supported&nbsp;</li><li>Unnumbered VTI is supported&nbsp;</li><li>Unnumbered VTI is <em>not</em> supported in 600 / 1100 appliances running R75.20.X firmware.</li><li>VTI is <em>not</em> supported on 40000 / 60000 Security System.</li><li>VTI interfaces are not supported in VSX mode.</li><li>QoS is <em>not</em> supported (<a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk34086" target="_blank" rel="noopener">sk34086</a>).</li></ul></td></tr><tr><td>VPN Shell for creating VTI</td><td><ul type="circle"><li><em>Not</em> supported (use <em>show vpn</em>, <em>add vpn</em>, and <em>delete vpn</em> commands).</li></ul></td></tr><tr><td>40000 / 60000 Security Systems</td><td><ul type="circle"><li>Traditional VPN mode is <em>not</em> supported.</li><li>Per-gateway VPN is <em>not</em> supported.</li><li>Virtual Tunnel Interfaces (VTI) are <em>not</em> supported.</li><li>IPSec VPN Link Selection Limitations:<br><ul type="square"><li>IP Selection by Remote Peer - supports only the 'Selected address from topology table' option.</li><li>Outgoing Route Selection - supports only the 'Operating system routing table' option.</li><li>Route based probing configuration is not supported for VPN Link Selection High Availability.</li></ul></li><li>For VPN, you must configure IPv6 for at least one interface when IPv6 is enabled.</li><li>SecureXL Templates for encrypted traffic are not supported.</li></ul></td></tr><tr><td>600 / 700 / 1100 / 1200R / 1400 appliances<br>running <em><strong>R77.20.X</strong></em> firmware</td><td><ul type="circle"><li>Traditional VPN mode is <em>not</em> supported in Centrally Managed mode.</li><li>Dead Peer Detection (DPD) is <em>not</em> supported in Centrally Managed and Locally Managed modes of the appliances.</li><li>The combined use of IKEv2 and IKEv1 Aggressive Mode is <em>not</em> supported.</li><li>Permanent Tunnels are <em>not</em> available when the VPN Site-to-Site configuration uses IKEv2 and one of the VPN sites has a dynamically allocated IP address (DAIP).</li><li>When the external interface is used as a Bridge to local networks, VPN Site-to-Site traffic is <em>not</em> supported.</li><li>For more information, refer to <a href="https://supportcenter.checkpoint.com/supportcenter/portal?eventSubmit_doGoviewsolutiondetails=&amp;solutionid=sk105380" target="_blank" rel="noopener">sk105380 - Check Point R77.20 for 600 / 700 / 1100 / 1200R / 1400 Appliance Known Limitations</a></li></ul></td></tr></tbody></table>